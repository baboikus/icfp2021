Утром 10 июля узнал из твиттера, что icfp2021 уже в разгаре(на light раунд я опоздал), зашёл на сайт, посмотрел спецификацию задачи. Пару раз до этого принимал участие в команде и в соло, знал, что для меня это скорее всего превратиться в истощающее программирование на выносливость, с очень низким результатом по сравнению с топами ладдера. Никаких планов на участие в этом году не было, но решил потратить часов 6-8 на решение хотя бы пары предложенных организаторами проблем.

Поверхностно разобрался в условиях базовой задачи. Для себя это назвал "красивая укладка графа с жесткими рёбрами в произвольную форму без дыр". До этого в универе чуть-чуть изучал проблему отрисовки графов, понимал, что это всё очень сложно, алгоритмов много, они нетривиальны и для понимания и для эффективной реализации. Ну окей, значит буду придумывать что-то своё, пусть даже это будет какой-то неэффективный перебор с участием эвристик и рандома.

По условиям задачи нам дано какоё-то "тело"(человечек, корги, паук, гроздь бананов), тело нужно пропихнуть через ограниченную область, не задевая границы области и не "разрушая" само тело. То есть у тела есть какие-то правила преобразований, которые неявно описаны в задаче в виде формул-ограничений. Так же оценивается и уродливость(в терминах задачи - дизлайки) принятой телом позы, как считать эту уродливость было явно прописано.

Смотрю на конкретные задачи, думаю, пытаюсь совместить понятия "непрерывность", "неизвестность" и "ограничения". Для меня все эти понятия указывают на выбор какого-нибудь generic nature-inspired алгоритма. Времени мало, поэтому буду пробовать самый простой генетический алгоритм, такие шутки я уже пару раз реализовывал в прошлом. ICFP это не место, чтобы учиться новым трюкам. По тем же причинам для реализации выбрал c++ плюс std либа.

Общая идея такая:
1. Создаём много-много копий изначального тела.
2. "Чуть-чуть" случайно шевелим каждую копию.
3. Выкидываем копии, шевеление которых нам не понравилось по каким-то критериям.
4. Из оставшихся хорошо пошевелившихся тел как-то делаем новые.
5. Далее идём в пункт 2 и повторяем, пока не надоест.
6. Если надоело, то считаем решением тело с самой хорошей позой.

Решение почти готово. Осталось всего ничего - определить, что значит "чуть-чуть" шевелим(мутируем!), какие шевеления нам не нравятся(проверка ограничений!), в чём выражается степень "хорошести" шевеления(фит-функция!), как делать из старых тел новые(скрещевание!) и когда нам всём это должно надоесть(условия останова!).

Но сначала надо распарсить json. И в std ничего для этого нет. Пришлось писать свой уродливый парсер для конкретной json-структуры задач. Генерировал json-ответы на задачи также через запись в обычный string.

Выразил общую идею алгоритма в коде с самыми тривиальными определениями мутаций, скрещеваний и всего вот этого вот. Начал придумывать какой-нибудь простенький способ мутации. Сначала попробовал просто шевелить одну вершину в теле случайно на +-1, и проверять, стало ли тело ближе к тому, чтобы хоть как-то целиком залезть в нужную форму. Программа что-то считала, выдавала какой-то json, но на сколько это хорошие решения и решения ли вообще мне не было понятно. Для визуальной интерпретации решений написал генерацию svg файликов.

Оказалось, что это вполне рабочий подход, но была проблема - программа работало очень и очень медленно, решения реальной задачи я не дождался за 10 минут. Нужна какая-то более агрессивная форма мутации.

Попробовал вращать всё тело вокруг своего центра на какой-то случайный угол. Для этого пришлось сначала вспомнить, что я умею в эти ваши синусы-косинусы, а потом найти готовое решение на stack-overflow. Добавил к этому случайное смещение всего тела. Всё начало работать сильно бодрее, меньше чем за минуту, тело из первой задачи сворачивалось в уродливый комок внутри нужной формы. Но, как оказалось тут же, были нюансы.

Автоматические судьи icfp оказывались принимать мои решения, потому что решения были с нецелыми значениями координат. Как-то я пропустил это важное ограничение в описании задачи. Нецелочисленность вылезала из операции поворота тела. Как от этого избавиться - не понятно. Но и чёрт с ним, просто округлю все результаты. Но снова беда - округлённые результаты не нравятся судьям из-за нарушений ограничений жесткости ребёр в теле, то есть мутации слишком сильно меняли изначальную длину ребёр. Ладно, добавлю проверку, что если какая-то мутация "порвала" или "сжала" хоть одно ребро в теле, то откатываем эту мутацию. И вот тут мне стало страшно - почти все приводящие к решению мутации нарушали ограничния на жесткость. Я не мог просто так повернуть тело, либо чуть-чуть подвинуть одну из вершин. Я помнил из программы универа что-то про вычислительную геометрию и компьютерную графику, и что есть какие-то правила для округления десятичных координат в целочисленные координаты пикселя на экране, но мне было сильно неохота в этом разбираться. К этому моменту я провёл почти 12 часов за написанием кода, уже ничего не соображал, поэтому просто пошёл спать, так и не увидев balonit_bros в ладдере.

Утром воскресенья обнаружил, что выкатили новую спецификацию задачи. Как обычно, это были всякие бонусные условия для решений, но мне было совсем не до них, тут бы хоть что-то рабочее выдавить. 

Я начал копаться в поисках инфы, как написать с нуля простейший физический движок, что-то типа ragdoll на минималках. Тянешь одну вершину тела, все остальные вершины смещаются для сохранения жесткости по какому-то неведомому закону. Все найденные мною туториалы использовали сторонние гейм-дев движки, from scratch обучалки найдено не было. Начал изобретать свой велосипед, но посидев часик понял, что такой матан мне не дастся меньше чем за сутки, да и не лежит у меня душа к такому решению.

Стал думать о способах мутации, при которых какая-то часть тела смещается целиком, а остальная часть остаётся в покое. Придумал пару таких мутаций.
1. Вершину, при удалении которой тело разбивается на две несвязнные части, назовём "мостом". Любую из этих частей можно вращать вокруг такого моста.
2. Пару вершин, при удалении которых тело разбивается на две несвязнные части, назовём "разрезом". Любую из этих частей можно зеркально отразить от линии, проведённой через вершины разреза.
Три-четыре часа ушли на сильно-сильно полиномиальную реализацию поиска таких вершин в теле и правку кучи обнаруженных по дороге багов в фит-функции(в этом сильно помогла визуализация решений в svg!). При этом всём, проблема с округлениями координат никуда не исчезла, и можно ли как-то подправлять координаты мне не было понятно. Но теперь судьи начали засчитывать решения, выдавая тысячи дизлайков. Добавил в фит-функцию расчёт дизлайков, сильно меньше их в итоге не стало, но и по времени мне это почти ничего не стоило. Команда balonit_bros ворвалась в лэддер на 150+ месте!  

Теперь пришло время автоматизировать решение и отправку результатов судьям. Для этого первый раз в жизни написал пару bash скриптов. Какие-то задачи программа решала за 10 секунд, а где-то тело принимало позу, любое корректное-изменение которой приводило к более плохому результату, на таких локальных-минимумах программа явно зависала. Но на этом этапе я уже было очень доволен - моя реализация генетического алгоритма способна получать хоть какие-то верные результаты. Я ещё пару часиков поэксперементировал с настройками алгоритма и пошёл спать. За этот день было потрачено ещё +10 часов.

Утром в понедельник попробовал добавить скрещивание тел. Берём два тела-родителя, получаем другие два тела-потомка, каждый потомок взял часть своих вершин от одного родителя, а остальные вершин от другого. В теории скрещивание - это важная часть генетического алгоритма. Скрещивал тела я с использованием упомянутых выше "срезов". Режем каждого родителя на две части по вершинам среза, склеиваем части разных родителем друг с другом так же по вершинам среза. Дало ли скрещиванием какой-то положительный результат мне было не ясно. Но было прикольно, что и тут пригодились эти срезы.

Для ряда задач указывалось, что в них возможно уложить тело в форму идеально, то есть получить ноль дизлайков. Я подумал, что некоторые такие задачи можно забрутофорсить, то есть перебором найти отображение координат вершин формы на вершины тела. Для ускорения такого перебора я придумал следующее:
1. Находим вершину в теле, из которой выходит ровно два ребра.
2. Замеряем длину ребёр, ищем в форме вершины(в форме у всех вершин ровно два ребра всегда) с такой же или почти такой же длиной.
3. Если такую вершину в форме нашли, то перемещаем и разворачиваем тело так, чтобы вершина и рёбра тела из пункта 1 совпала с вершиной и рёбрами формы из пункта 2.
4. Проверяем ограничения и считаем дизайки. Если всё хорошо, то вот оно решение.
Если проще - то пытаемся как-то повернуть и сдвинуть тело, чтобы оно влезло в нужную форму. 
Но на проверке этой гипотезы я понял, что вымотан окончательно, не мог даже написать функцию нахождения угла между парой векторов, выходящих из одной точки. В итоге просто проверил все свои отосланные решения на сайте icfp, скачал и переслал самые лучшие. В 15 часов по МСК моё участие в соревнованиях завершилось. На код и размышления было потрачено около 25 часов. Очень устал и больше ничего не хочу. Через пару суток были доступны окончательные результаты: 110 место и 94927 очков, это очень мало по сравнению с результатами команд выше, но меня это не расстраивает.

Чему меня всё это научило:
1. Нужно заранее иметь код или либу для простой работы с json.
2. Ещё до реализации конкретных решений надо сделать хоть какое-то самое простое визуальное представление условий задачи и решений.
3. Если есть какие-то фундаментальные ограничения в задаче(целочисленность координат и жесткость ребёр), то про них нужно думать сразу. Почти все мои мутации нарушали эти ограничения и отбрасывались как некорректные.
4. Генетические алгоритмы - это суперуниверсальная штука. Но не стоит рассчитывать на хороший результат, если нет правильно подобранных способов мутации и фит-функций. В моём случае получалось скомканное тело случайно размещённое внутри ограничений.
5. Решение перебором - это нормально.
6. Искать полностью независимые решения для специальных случаев - это нормально.
7. После 6-8 часов непрерывной работы над задачей, надо всё бросать и идти отдыхать.
8. Если не хочешь получить нервный срыв за выходные из-за icfp, то просто прими участи в лайт раунде и забей.